<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/kurento-client-elements/lib/WebRtcEndpoint.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/kurento-client-elements/lib/WebRtcEndpoint.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Autogenerated with Kurento Idl */

/*
 * (C) Copyright 2013-2015 Kurento (http://kurento.org/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var inherits = require('inherits');

var kurentoClient = require('kurento-client');

var disguise = kurentoClient.disguise;

var checkType      = kurentoClient.checkType;
var ChecktypeError = checkType.ChecktypeError;


var Transaction = kurentoClient.TransactionsManager.Transaction;

var BaseRtpEndpoint = require('kurento-client-core').abstracts.BaseRtpEndpoint;


function noop(error, result) {
  if (error) console.trace(error);

  return result
};


/**
 * Builder for the {@link module:elements.WebRtcEndpoint WebRtcEndpoint}
 *
 * @classdesc
 *  &lt;p>
 *        Control interface for Kurento WebRTC endpoint.
 *        &lt;/p>
 *        &lt;p>
 *        This endpoint is one side of a peer-to-peer WebRTC communication, 
 *        being the other peer a WebRTC capable browser -using the 
 *        RTCPeerConnection API-, a native WebRTC app or even another Kurento 
 *        Media Server.
 *        &lt;/p>
 *        &lt;p>
 *        In order to establish a WebRTC communication, peers engage in an SDP 
 *        negotiation process, where one of the peers (the offerer) sends an 
 *        offer, while the other peer (the offeree) responds with an answer. 
 *        This endpoint can function in both situations
 *        &lt;ul>
 *          &lt;li>
 *            As offerer: The negotiation process is initiated by the media 
 *            server
 *            &lt;ul style='list-style-type:circle'>
 *              &lt;li>KMS generates the SDP offer through the 
 *              &lt;code>generateOffer&lt;/code> method. This &lt;i>offer&lt;/i> must then 
 *              be sent to the remote peer (the offeree) through the signaling 
 *              channel, for processing.&lt;/li>
 *              &lt;li>The remote peer process the &lt;i>offer&lt;/i>, and generates an 
 *              &lt;i>answer&lt;/i> to this &lt;i>offer&lt;/i>. The &lt;i>answer&lt;/i> is sent 
 *              back to the media server.&lt;/li>
 *              &lt;li>Upon receiving the &lt;i>answer&lt;/i>, the endpoint must invoke 
 *              the &lt;code>processAnswer&lt;/code> method.&lt;/li>
 *            &lt;/ul>
 *          &lt;/li>
 *          &lt;li>
 *            As offeree: The negotiation process is initiated by the remote 
 *            peer
 *            &lt;ul>
 *              &lt;li>The remote peer, acting as offerer, generates an SDP 
 *              &lt;i>offer&lt;/i> and sends it to the WebRTC endpoint in 
 *              Kurento.&lt;/li>
 *              &lt;li>The endpoint will process the &lt;i>offer&lt;/i> invoking the 
 *              &lt;code>processOffer&lt;/code> method. The result of this method will
 *              &lt;li>The SDP &lt;i>answer&lt;/i> must be sent back to the offerer, so 
 *              it can be processed.&lt;/li>
 *            &lt;/ul>
 *          &lt;/li>
 *        &lt;/ul>
 *        &lt;/p>
 *        &lt;p>
 *        SDPs are sent without ICE candidates, following the Trickle ICE 
 *        optimization. Once the SDP negotiation is completed, both peers 
 *        proceed with the ICE discovery process, intended to set up a 
 *        bidirectional media connection. During this process, each peer
 *        &lt;ul>
 *          &lt;li>Discovers ICE candidates for itself, containing pairs of IPs and
 *          &lt;li>ICE candidates are sent via the signaling channel as they are 
 *          discovered, to the remote peer for probing.&lt;/li>
 *          &lt;li>ICE connectivity checks are run as soon as the new candidate 
 *          description, from the remote peer, is available.&lt;/li>
 *        &lt;/ul>
 *        Once a suitable pair of candidates (one for each peer) is discovered, 
 *        the media session can start. The harvesting process in Kurento, begins
 *        &lt;/p>
 *        &lt;p>
 *        It's important to keep in mind that WebRTC connection is an 
 *        asynchronous process, when designing interactions between different 
 *        MediaElements. For example, it would be pointless to start recording 
 *        before media is flowing. In order to be notified of state changes, the
 *        &lt;ul>
 *          &lt;li>
 *            &lt;code>IceComponentStateChange&lt;/code>: This event informs only 
 *            about changes in the ICE connection state. Possible values are:
 *            &lt;ul style='list-style-type:circle'>
 *              &lt;li>&lt;code>DISCONNECTED&lt;/code>: No activity scheduled&lt;/li>
 *              &lt;li>&lt;code>GATHERING&lt;/code>: Gathering local candidates&lt;/li>
 *              &lt;li>&lt;code>CONNECTING&lt;/code>: Establishing connectivity&lt;/li>
 *              &lt;li>&lt;code>CONNECTED&lt;/code>: At least one working candidate 
 *              pair&lt;/li>
 *              &lt;li>&lt;code>READY&lt;/code>: ICE concluded, candidate pair selection 
 *              is now final&lt;/li>
 *              &lt;li>&lt;code>FAILED&lt;/code>: Connectivity checks have been 
 *              completed, but media connection was not established&lt;/li>
 *            &lt;/ul>
 *            The transitions between states are covered in RFC5245.
 *            It could be said that it's network-only, as it only takes into 
 *            account the state of the network connection, ignoring other higher
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>IceCandidateFound&lt;/code>: Raised when a new candidate is 
 *            discovered. ICE candidates must be sent to the remote peer of the 
 *            connection. Failing to do so for some or all of the candidates 
 *            might render the connection unusable.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>IceGatheringDone&lt;/code>: Raised when the ICE harvesting 
 *            process is completed. This means that all candidates have already 
 *            been discovered.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>NewCandidatePairSelected&lt;/code>: Raised when a new ICE 
 *            candidate pair gets selected. The pair contains both local and 
 *            remote candidates being used for a component. This event can be 
 *            raised during a media session, if a new pair of candidates with 
 *            higher priority in the link are found.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>DataChannelOpen&lt;/code>: Raised when a data channel is open.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>DataChannelClose&lt;/code>: Raised when a data channel is 
 *            closed.
 *          &lt;/li>
 *        &lt;/ul>
 *        &lt;/p>
 *        &lt;p>
 *        Registering to any of above events requires the application to provide
 *        &lt;/p>
 *        &lt;p>
 *        Flow control and congestion management is one of the most important 
 *        features of WebRTC. WebRTC connections start with the lowest bandwidth
 *        &lt;/p>
 *        &lt;p>
 *        The default bandwidth range of the endpoint is 100kbps-500kbps, but it
 *        &lt;ul>
 *          &lt;li>
 *            Input bandwidth control mechanism: Configuration interval used to 
 *            inform remote peer the range of bitrates that can be pushed into 
 *            this WebRtcEndpoint object.
 *            &lt;ul style='list-style-type:circle'>
 *              &lt;li>
 *                setMin/MaxVideoRecvBandwidth: sets Min/Max bitrate limits 
 *                expected for received video stream.
 *              &lt;/li>
 *              &lt;li>
 *                setMin/MaxAudioRecvBandwidth: sets Min/Max bitrate limits 
 *                expected for received audio stream.
 *              &lt;/li>
 *            &lt;/ul>
 *            Max values are announced in the SDP, while min values are set to 
 *            limit the lower value of REMB packages. It follows that min values
 *          &lt;/li>
 *          &lt;li>
 *            Output bandwidth control mechanism: Configuration interval used to
 *            &lt;ul style='list-style-type:circle'>
 *              &lt;li>
 *                setMin/MaxVideoSendBandwidth: sets Min/Max bitrate limits  for
 *              &lt;/li>
 *            &lt;/ul>
 *          &lt;/li>
 *        &lt;/ul>
 *        All bandwidth control parameters must be changed before the SDP 
 *        negotiation takes place, and can't be changed afterwards.
 *        &lt;/p>
 *        &lt;p>
 *        DataChannels allow other media elements that make use of the DataPad, 
 *        to send arbitrary data. For instance, if there is a filter that 
 *        publishes event information, it'll be sent to the remote peer through 
 *        the channel. There is no API available for programmers to make use of 
 *        this feature in the WebRtcElement. DataChannels can be configured to 
 *        provide the following:
 *        &lt;ul>
 *          &lt;li>
 *            Reliable or partially reliable delivery of sent messages
 *          &lt;/li>
 *          &lt;li>
 *            In-order or out-of-order delivery of sent messages
 *          &lt;/li>
 *        &lt;/ul>
 *        Unreliable, out-of-order delivery is equivalent to raw UDP semantics. 
 *        The message may make it, or it may not, and order is not important. 
 *        However, the channel can be configured to be &lt;i>partially reliable&lt;/i>
 *        &lt;/p>
 *        &lt;p>
 *        The possibility to create DataChannels in a WebRtcEndpoint must be 
 *        explicitly enabled when creating the endpoint, as this feature is 
 *        disabled by default. If this is the case, they can be created invoking
 *        &lt;ul>
 *          &lt;li>
 *           &lt;code>label&lt;/code>: assigns a label to the DataChannel. This can 
 *           help identify each possible channel separately.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>ordered&lt;/code>: specifies if the DataChannel guarantees 
 *            order, which is the default mode. If maxPacketLifetime and 
 *            maxRetransmits have not been set, this enables reliable mode.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>maxPacketLifeTime&lt;/code>: The time window in milliseconds, 
 *            during which transmissions and retransmissions may take place in 
 *            unreliable mode. This forces unreliable mode, even if 
 *            &lt;code>ordered&lt;/code> has been activated.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>maxRetransmits&lt;/code>: maximum number of retransmissions 
 *            that are attempted in unreliable mode. This forces unreliable 
 *            mode, even if &lt;code>ordered&lt;/code> has been activated.
 *          &lt;/li>
 *          &lt;li>
 *            &lt;code>Protocol&lt;/code>: Name of the subprotocol used for data 
 *            communication.
 *          &lt;/li>
 *        &lt;/ul>
 *
 * @extends module:core/abstracts.BaseRtpEndpoint
 *
 * @constructor module:elements.WebRtcEndpoint
 *
 * @fires {@link module:elements#event:DataChannelClose DataChannelClose}
 * @fires {@link module:elements#event:DataChannelOpen DataChannelOpen}
 * @fires {@link module:elements#event:IceCandidateFound IceCandidateFound}
 * @fires {@link module:elements#event:IceComponentStateChange IceComponentStateChange}
 * @fires {@link module:elements#event:IceGatheringDone IceGatheringDone}
 * @fires {@link module:elements#event:NewCandidatePairSelected NewCandidatePairSelected}
 * @fires {@link module:elements#event:OnDataChannelClosed OnDataChannelClosed}
 * @fires {@link module:elements#event:OnDataChannelOpened OnDataChannelOpened}
 * @fires {@link module:elements#event:OnIceCandidate OnIceCandidate}
 * @fires {@link module:elements#event:OnIceComponentStateChanged OnIceComponentStateChanged}
 * @fires {@link module:elements#event:OnIceGatheringDone OnIceGatheringDone}
 */
function WebRtcEndpoint(){
  WebRtcEndpoint.super_.call(this);
};
inherits(WebRtcEndpoint, BaseRtpEndpoint);


//
// Public properties
//

/**
 * the ICE candidate pair (local and remote candidates) used by the ice library 
 * for each stream.
 *
 * @alias module:elements.WebRtcEndpoint#getICECandidatePairs
 *
 * @param {module:elements.WebRtcEndpoint~getICECandidatePairsCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.getICECandidatePairs = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'getICECandidatePairs', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~getICECandidatePairsCallback
 * @param {external:Error} error
 * @param {module:elements/complexTypes.IceCandidatePair} result
 */

/**
 * the ICE connection state for all the connections.
 *
 * @alias module:elements.WebRtcEndpoint#getIceConnectionState
 *
 * @param {module:elements.WebRtcEndpoint~getIceConnectionStateCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.getIceConnectionState = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'getIceConnectionState', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~getIceConnectionStateCallback
 * @param {external:Error} error
 * @param {module:elements/complexTypes.IceConnection} result
 */

/**
 * address of the STUN server (Only IP address are supported)
 *
 * @alias module:elements.WebRtcEndpoint#getStunServerAddress
 *
 * @param {module:elements.WebRtcEndpoint~getStunServerAddressCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.getStunServerAddress = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'getStunServerAddress', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~getStunServerAddressCallback
 * @param {external:Error} error
 * @param {external:String} result
 */

/**
 * address of the STUN server (Only IP address are supported)
 *
 * @alias module:elements.WebRtcEndpoint#setStunServerAddress
 *
 * @param {external:String} stunServerAddress
 * @param {module:elements.WebRtcEndpoint~setStunServerAddressCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.setStunServerAddress = function(stunServerAddress, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  //  
  // checkType('String', 'stunServerAddress', stunServerAddress, {required: true});
  //  

  var params = {
    stunServerAddress: stunServerAddress
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'setStunServerAddress', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~setStunServerAddressCallback
 * @param {external:Error} error
 */

/**
 * port of the STUN server
 *
 * @alias module:elements.WebRtcEndpoint#getStunServerPort
 *
 * @param {module:elements.WebRtcEndpoint~getStunServerPortCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.getStunServerPort = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'getStunServerPort', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~getStunServerPortCallback
 * @param {external:Error} error
 * @param {external:Integer} result
 */

/**
 * port of the STUN server
 *
 * @alias module:elements.WebRtcEndpoint#setStunServerPort
 *
 * @param {external:Integer} stunServerPort
 * @param {module:elements.WebRtcEndpoint~setStunServerPortCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.setStunServerPort = function(stunServerPort, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  //  
  // checkType('int', 'stunServerPort', stunServerPort, {required: true});
  //  

  var params = {
    stunServerPort: stunServerPort
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'setStunServerPort', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~setStunServerPortCallback
 * @param {external:Error} error
 */

/**
 * TURN server URL with this format: 
 * &lt;code>user:password@address:port(?transport=[udp|tcp|tls])&lt;/code>.&lt;/br>&lt;code>address&lt;/code>
 *
 * @alias module:elements.WebRtcEndpoint#getTurnUrl
 *
 * @param {module:elements.WebRtcEndpoint~getTurnUrlCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.getTurnUrl = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'getTurnUrl', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~getTurnUrlCallback
 * @param {external:Error} error
 * @param {external:String} result
 */

/**
 * TURN server URL with this format: 
 * &lt;code>user:password@address:port(?transport=[udp|tcp|tls])&lt;/code>.&lt;/br>&lt;code>address&lt;/code>
 *
 * @alias module:elements.WebRtcEndpoint#setTurnUrl
 *
 * @param {external:String} turnUrl
 * @param {module:elements.WebRtcEndpoint~setTurnUrlCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.setTurnUrl = function(turnUrl, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  //  
  // checkType('String', 'turnUrl', turnUrl, {required: true});
  //  

  var params = {
    turnUrl: turnUrl
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'setTurnUrl', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~setTurnUrlCallback
 * @param {external:Error} error
 */


//
// Public methods
//

/**
 * Process an ICE candidate sent by the remote peer of the connection.
 *
 * @alias module:elements.WebRtcEndpoint.addIceCandidate
 *
 * @param {module:elements/complexTypes.IceCandidate} candidate
 *  Remote ICE candidate
 *
 * @param {module:elements.WebRtcEndpoint~addIceCandidateCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.addIceCandidate = function(candidate, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  //  
  // checkType('IceCandidate', 'candidate', candidate, {required: true});
  //  

  var params = {
    candidate: candidate
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'addIceCandidate', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~addIceCandidateCallback
 * @param {external:Error} error
 */

/**
 * Closes an open data channel
 *
 * @alias module:elements.WebRtcEndpoint.closeDataChannel
 *
 * @param {external:Integer} channelId
 *  The channel identifier
 *
 * @param {module:elements.WebRtcEndpoint~closeDataChannelCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.closeDataChannel = function(channelId, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  //  
  // checkType('int', 'channelId', channelId, {required: true});
  //  

  var params = {
    channelId: channelId
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'closeDataChannel', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~closeDataChannelCallback
 * @param {external:Error} error
 */

/**
 * Create a new data channel, if data channels are supported. If they are not 
 * supported, this method throws an exception.
 *           Being supported means that the WebRtcEndpoint has been created with
 *           Otherwise, the method throws an exception, indicating that the 
 *           operation is not possible.&lt;/br>
 *           Data channels can work in either unreliable mode (analogous to User
 *           The two modes have a simple distinction:
 *           &lt;ul>
 *             &lt;li>Reliable mode guarantees the transmission of messages and 
 *             also the order in which they are delivered. This takes extra 
 *             overhead, thus potentially making this mode slower.&lt;/li>
 *             &lt;li>Unreliable mode does not guarantee every message will get to 
 *             the other side nor what order they get there. This removes the 
 *             overhead, allowing this mode to work much faster.&lt;/li>
 *           &lt;/ul>
 *
 * @alias module:elements.WebRtcEndpoint.createDataChannel
 *
 * @param {external:String} [label]
 *  Channel's label
 *
 * @param {external:Boolean} [ordered]
 *  If the data channel should guarantee order or not. If true, and 
 *  maxPacketLifeTime and maxRetransmits have not been provided, reliable mode 
 *  is activated.
 *
 * @param {external:Integer} [maxPacketLifeTime]
 *  The time window (in milliseconds) during which transmissions and 
 *  retransmissions may take place in unreliable mode.&lt;/br>
 *                &lt;hr/>&lt;b>Note&lt;/b> This forces unreliable mode, even if 
 *                &lt;code>ordered&lt;/code> has been activated
 *
 * @param {external:Integer} [maxRetransmits]
 *  maximum number of retransmissions that are attempted in unreliable 
 *  mode.&lt;/br>
 *                &lt;hr/>&lt;b>Note&lt;/b> This forces unreliable mode, even if 
 *                &lt;code>ordered&lt;/code> has been activated
 *
 * @param {external:String} [protocol]
 *  Name of the subprotocol used for data communication
 *
 * @param {module:elements.WebRtcEndpoint~createDataChannelCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.createDataChannel = function(label, ordered, maxPacketLifeTime, maxRetransmits, protocol, callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  callback = arguments[arguments.length-1] instanceof Function
           ? Array.prototype.pop.call(arguments)
           : undefined;

  switch(arguments.length){
    case 0: label = undefined;
    case 1: ordered = undefined;
    case 2: maxPacketLifeTime = undefined;
    case 3: maxRetransmits = undefined;
    case 4: protocol = undefined;
    break;
    case 5: 
    break;

    default:
      var error = new RangeError('Number of params ('+arguments.length+') not in range [0-5]');
          error.length = arguments.length;
          error.min = 0;
          error.max = 5;

      throw error;
  }

  //  
  // checkType('String', 'label', label);
  //  
  // checkType('boolean', 'ordered', ordered);
  //  
  // checkType('int', 'maxPacketLifeTime', maxPacketLifeTime);
  //  
  // checkType('int', 'maxRetransmits', maxRetransmits);
  //  
  // checkType('String', 'protocol', protocol);
  //  

  var params = {
    label: label,
    ordered: ordered,
    maxPacketLifeTime: maxPacketLifeTime,
    maxRetransmits: maxRetransmits,
    protocol: protocol
  };

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'createDataChannel', params, callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~createDataChannelCallback
 * @param {external:Error} error
 */

/**
 * Start the gathering of ICE candidates.&lt;/br>It must be called after 
 * SdpEndpoint::generateOffer or SdpEndpoint::processOffer for Trickle ICE. If 
 * invoked before generating or processing an SDP offer, the candidates gathered
 *
 * @alias module:elements.WebRtcEndpoint.gatherCandidates
 *
 * @param {module:elements.WebRtcEndpoint~gatherCandidatesCallback} [callback]
 *
 * @return {external:Promise}
 */
WebRtcEndpoint.prototype.gatherCandidates = function(callback){
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  var usePromise = false;
  
  if (callback == undefined) {
    usePromise = true;
  }
  
  if(!arguments.length) callback = undefined;

  callback = (callback || noop).bind(this)

  return disguise(this._invoke(transaction, 'gatherCandidates', callback), this)
};
/**
 * @callback module:elements.WebRtcEndpoint~gatherCandidatesCallback
 * @param {external:Error} error
 */


/**
 * @alias module:elements.WebRtcEndpoint.constructorParams
 *
 * @property {module:elements/complexTypes.CertificateKeyType} [certificateKeyType]
 *  Define the type of the certificate used in dtls
 *
 * @property {module:core.MediaPipeline} mediaPipeline
 *  the {@link module:core.MediaPipeline MediaPipeline} to which the endpoint 
 *  belongs
 *
 * @property {external:Boolean} [recvonly]
 *  Single direction, receive-only endpoint
 *
 * @property {external:Boolean} [sendonly]
 *  Single direction, send-only endpoint
 *
 * @property {external:Boolean} [useDataChannels]
 *  Activate data channels support
 */
WebRtcEndpoint.constructorParams = {
  certificateKeyType: {
    type: 'kurento.CertificateKeyType'  },
  mediaPipeline: {
    type: 'kurento.MediaPipeline',
    required: true
  },
  recvonly: {
    type: 'boolean'  },
  sendonly: {
    type: 'boolean'  },
  useDataChannels: {
    type: 'boolean'  }
};

/**
 * @alias module:elements.WebRtcEndpoint.events
 *
 * @extends module:core/abstracts.BaseRtpEndpoint.events
 */
WebRtcEndpoint.events = BaseRtpEndpoint.events.concat(['DataChannelClose', 'DataChannelOpen', 'IceCandidateFound', 'IceComponentStateChange', 'IceGatheringDone', 'NewCandidatePairSelected', 'OnDataChannelClosed', 'OnDataChannelOpened', 'OnIceCandidate', 'OnIceComponentStateChanged', 'OnIceGatheringDone']);


/**
 * Checker for {@link module:elements.WebRtcEndpoint}
 *
 * @memberof module:elements
 *
 * @param {external:String} key
 * @param {module:elements.WebRtcEndpoint} value
 */
function checkWebRtcEndpoint(key, value)
{
  if(!(value instanceof WebRtcEndpoint))
    throw ChecktypeError(key, WebRtcEndpoint, value);
};


module.exports = WebRtcEndpoint;

WebRtcEndpoint.check = checkWebRtcEndpoint;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-core.html">core</a></li><li><a href="module-core_abstracts.html">core/abstracts</a></li><li><a href="module-core_complexTypes.html">core/complexTypes</a></li><li><a href="module-elements.html">elements</a></li><li><a href="module-elements_abstracts.html">elements/abstracts</a></li><li><a href="module-elements_complexTypes.html">elements/complexTypes</a></li><li><a href="module-filters.html">filters</a></li><li><a href="module-filters_abstracts.html">filters/abstracts</a></li><li><a href="module-kurentoClient.html">kurentoClient</a></li></ul><h3>Externals</h3><ul><li><a href="external-Boolean.html">Boolean</a></li><li><a href="external-Error.html">Error</a></li><li><a href="external-EventEmitter.html">EventEmitter</a></li><li><a href="external-Integer.html">Integer</a></li><li><a href="external-Number.html">Number</a></li><li><a href="external-Object.html">Object</a></li><li><a href="external-Promise.html">Promise</a></li><li><a href="external-String.html">String</a></li></ul><h3>Classes</h3><ul><li><a href="module-core.HubPort.html">HubPort</a></li><li><a href="module-core.MediaPipeline.html">MediaPipeline</a></li><li><a href="module-core.PassThrough.html">PassThrough</a></li><li><a href="module-core_abstracts.BaseRtpEndpoint.html">BaseRtpEndpoint</a></li><li><a href="module-core_abstracts.Endpoint.html">Endpoint</a></li><li><a href="module-core_abstracts.Filter.html">Filter</a></li><li><a href="module-core_abstracts.Hub.html">Hub</a></li><li><a href="module-core_abstracts.MediaElement.html">MediaElement</a></li><li><a href="module-core_abstracts.MediaObject.html">MediaObject</a></li><li><a href="module-core_abstracts.SdpEndpoint.html">SdpEndpoint</a></li><li><a href="module-core_abstracts.ServerManager.html">ServerManager</a></li><li><a href="module-core_abstracts.SessionEndpoint.html">SessionEndpoint</a></li><li><a href="module-core_abstracts.UriEndpoint.html">UriEndpoint</a></li><li><a href="module-core_complexTypes.AudioCaps.html">AudioCaps</a></li><li><a href="module-core_complexTypes.CodecConfiguration.html">CodecConfiguration</a></li><li><a href="module-core_complexTypes.ComplexType.html">ComplexType</a></li><li><a href="module-core_complexTypes.ElementConnectionData.html">ElementConnectionData</a></li><li><a href="module-core_complexTypes.ElementStats.html">ElementStats</a></li><li><a href="module-core_complexTypes.EndpointStats.html">EndpointStats</a></li><li><a href="module-core_complexTypes.Fraction.html">Fraction</a></li><li><a href="module-core_complexTypes.MediaLatencyStat.html">MediaLatencyStat</a></li><li><a href="module-core_complexTypes.ModuleInfo.html">ModuleInfo</a></li><li><a href="module-core_complexTypes.RembParams.html">RembParams</a></li><li><a href="module-core_complexTypes.RTCCertificateStats.html">RTCCertificateStats</a></li><li><a href="module-core_complexTypes.RTCCodec.html">RTCCodec</a></li><li><a href="module-core_complexTypes.RTCDataChannelStats.html">RTCDataChannelStats</a></li><li><a href="module-core_complexTypes.RTCIceCandidateAttributes.html">RTCIceCandidateAttributes</a></li><li><a href="module-core_complexTypes.RTCIceCandidatePairStats.html">RTCIceCandidatePairStats</a></li><li><a href="module-core_complexTypes.RTCInboundRTPStreamStats.html">RTCInboundRTPStreamStats</a></li><li><a href="module-core_complexTypes.RTCMediaStreamStats.html">RTCMediaStreamStats</a></li><li><a href="module-core_complexTypes.RTCMediaStreamTrackStats.html">RTCMediaStreamTrackStats</a></li><li><a href="module-core_complexTypes.RTCOutboundRTPStreamStats.html">RTCOutboundRTPStreamStats</a></li><li><a href="module-core_complexTypes.RTCPeerConnectionStats.html">RTCPeerConnectionStats</a></li><li><a href="module-core_complexTypes.RTCRTPStreamStats.html">RTCRTPStreamStats</a></li><li><a href="module-core_complexTypes.RTCStats.html">RTCStats</a></li><li><a href="module-core_complexTypes.RTCTransportStats.html">RTCTransportStats</a></li><li><a href="module-core_complexTypes.ServerInfo.html">ServerInfo</a></li><li><a href="module-core_complexTypes.Stats.html">Stats</a></li><li><a href="module-core_complexTypes.Tag.html">Tag</a></li><li><a href="module-core_complexTypes.VideoCaps.html">VideoCaps</a></li><li><a href="module-elements.AlphaBlending.html">AlphaBlending</a></li><li><a href="module-elements.Composite.html">Composite</a></li><li><a href="module-elements.Dispatcher.html">Dispatcher</a></li><li><a href="module-elements.DispatcherOneToMany.html">DispatcherOneToMany</a></li><li><a href="module-elements.HttpPostEndpoint.html">HttpPostEndpoint</a></li><li><a href="module-elements.Mixer.html">Mixer</a></li><li><a href="module-elements.PlayerEndpoint.html">PlayerEndpoint</a></li><li><a href="module-elements.RecorderEndpoint.html">RecorderEndpoint</a></li><li><a href="module-elements.RtpEndpoint.html">RtpEndpoint</a></li><li><a href="module-elements.WebRtcEndpoint.html">WebRtcEndpoint</a></li><li><a href="module-elements_abstracts.HttpEndpoint.html">HttpEndpoint</a></li><li><a href="module-elements_complexTypes.IceCandidate.html">IceCandidate</a></li><li><a href="module-elements_complexTypes.IceCandidatePair.html">IceCandidatePair</a></li><li><a href="module-elements_complexTypes.IceConnection.html">IceConnection</a></li><li><a href="module-elements_complexTypes.SDES.html">SDES</a></li><li><a href="module-elements_complexTypes.VideoInfo.html">VideoInfo</a></li><li><a href="module-filters.FaceOverlayFilter.html">FaceOverlayFilter</a></li><li><a href="module-filters.GStreamerFilter.html">GStreamerFilter</a></li><li><a href="module-filters.ImageOverlayFilter.html">ImageOverlayFilter</a></li><li><a href="module-filters.ZBarFilter.html">ZBarFilter</a></li><li><a href="module-filters_abstracts.OpenCVFilter.html">OpenCVFilter</a></li><li><a href="module-kurentoClient.KurentoClient.html">KurentoClient</a></li><li><a href="module-kurentoClient-MediaObjectCreator.html">MediaObjectCreator</a></li></ul><h3>Events</h3><ul><li><a href="module-core.html#event:ConnectionStateChanged">ConnectionStateChanged</a></li><li><a href="module-core.html#event:ElementConnected">ElementConnected</a></li><li><a href="module-core.html#event:ElementDisconnected">ElementDisconnected</a></li><li><a href="module-core.html#event:Error">Error</a></li><li><a href="module-core.html#event:Media">Media</a></li><li><a href="module-core.html#event:MediaFlowInStateChange">MediaFlowInStateChange</a></li><li><a href="module-core.html#event:MediaFlowOutStateChange">MediaFlowOutStateChange</a></li><li><a href="module-core.html#event:MediaSessionStarted">MediaSessionStarted</a></li><li><a href="module-core.html#event:MediaSessionTerminated">MediaSessionTerminated</a></li><li><a href="module-core.html#event:MediaStateChanged">MediaStateChanged</a></li><li><a href="module-core.html#event:MediaTranscodingStateChange">MediaTranscodingStateChange</a></li><li><a href="module-core.html#event:ObjectCreated">ObjectCreated</a></li><li><a href="module-core.html#event:ObjectDestroyed">ObjectDestroyed</a></li><li><a href="module-core.html#event:RaiseBase">RaiseBase</a></li><li><a href="module-core.html#event:UriEndpointStateChanged">UriEndpointStateChanged</a></li><li><a href="module-elements.html#event:DataChannelClose">DataChannelClose</a></li><li><a href="module-elements.html#event:DataChannelOpen">DataChannelOpen</a></li><li><a href="module-elements.html#event:EndOfStream">EndOfStream</a></li><li><a href="module-elements.html#event:IceCandidateFound">IceCandidateFound</a></li><li><a href="module-elements.html#event:IceComponentStateChange">IceComponentStateChange</a></li><li><a href="module-elements.html#event:IceGatheringDone">IceGatheringDone</a></li><li><a href="module-elements.html#event:NewCandidatePairSelected">NewCandidatePairSelected</a></li><li><a href="module-elements.html#event:OnDataChannelClosed">OnDataChannelClosed</a></li><li><a href="module-elements.html#event:OnDataChannelOpened">OnDataChannelOpened</a></li><li><a href="module-elements.html#event:OnIceCandidate">OnIceCandidate</a></li><li><a href="module-elements.html#event:OnIceComponentStateChanged">OnIceComponentStateChanged</a></li><li><a href="module-elements.html#event:OnIceGatheringDone">OnIceGatheringDone</a></li><li><a href="module-elements.html#event:OnKeySoftLimit">OnKeySoftLimit</a></li><li><a href="module-elements.html#event:Paused">Paused</a></li><li><a href="module-elements.html#event:Recording">Recording</a></li><li><a href="module-elements.html#event:Stopped">Stopped</a></li><li><a href="module-filters.html#event:CodeFound">CodeFound</a></li></ul><h3>Global</h3><ul><li><a href="global.html#create">create</a></li><li><a href="global.html#disguise">disguise</a></li><li><a href="global.html#disguiseThenable">disguiseThenable</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#promiseCatch">promiseCatch</a></li><li><a href="global.html#unthenable">unthenable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Nov 14 2018 16:04:19 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
